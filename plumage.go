package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

var tmpl = template.Must(template.New("tmpl").Funcs(
	template.FuncMap{},
).Parse(`// Code generated by plumage - DO NOT EDIT.

package {{ .PkgName }}

{{- range .TypeInfos.Interfaces }}{{ $TypeInfo := . }}
type {{ .Name }}Struct struct {
	{{- range .FieldInfos }}
		{{ .Name }}_ {{ .FullTypeName }}
	{{- end }}
}

{{- range .FieldInfos }}
func (v {{ $TypeInfo.Name }}Struct) {{ .Name }}() {{ .FullTypeName }} {
	return v.{{ .Name }}_
}

{{ end }}{{ end }}

{{- range .TypeInfos.Interfaces }}
func New{{ .Name }}Struct(v {{ .Name }}) {{ .Name }} {
	if v == nil {
		return nil
	}
	switch {{ if ne 0 .ChildCount }}t := {{ end }}v.(type) {
	{{- range .Child }}
	case {{ . }}:
		return New{{ . }}Struct(t)
	{{- end }}
	default:
		return {{ .Name }}Struct{
			{{- range .FieldInfos }}
				{{- if .IsInterface }}
					{{- if lt 0 .ArrayCount }}
						{{ .Name }}_: New{{ .TypeName }}StructList(v.{{ .Name }}()),
					{{- else }}
						{{ .Name }}_: New{{ .TypeName }}Struct(v.{{ .Name }}()),
					{{- end }}
				{{- else }}
					{{ .Name }}_: v.{{ .Name }}(),
				{{- end }}
			{{- end }}
		}
	}
}

func New{{ .Name }}StructList(vs []{{ .Name }}) []{{ .Name }} {
	ret := make([]{{ .Name }}, 0, len(vs))
	for _, v := range vs {
		ret = append(ret, New{{ .Name }}Struct(v))
	}
	return ret
}

{{ end }}
`))

func main() {
	var src, suffix string
	flag.StringVar(&src, "src", "", "code generate source")
	flag.StringVar(&suffix, "output file suffix", ".gen_test.go", "default .gen_test.go")
	flag.Parse()

	if src == "" {
		src = filepath.Dir(os.Getenv("GOFILE"))
	}

	if err := run(src, suffix); err != nil {
		log.Fatalf("[ERROR] %s", err)
	}
}

func run(src, suffix string) error {
	tinfos, err := inspect(src)
	if err != nil {
		return err
	}

	var pkgName string
	for _, tinfo := range tinfos {
		pkgName = tinfo.PkgName
		break
	}

	buf := &bytes.Buffer{}
	tmpl.Execute(buf, struct {
		TypeInfos TypeInfos
		PkgName   string
	}{
		TypeInfos: tinfos,
		PkgName:   pkgName,
	})

	// format と import を goimport に丸投げ
	formattedBytes, err := imports.Process("", buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("RUn: fail to goimport: source=\n%s\n, error=%w", buf.String(), err)
	}
	formatted := bytes.NewBuffer(formattedBytes)

	dst := filepath.Join(src, pkgName+suffix)
	f, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("Run: fail to create file: filename=%s, error=%w", dst, err)
	}
	defer f.Close()
	_, err = formatted.WriteTo(f)
	if err != nil {
		return fmt.Errorf("Run: fail to write file: filename=%s, error=%w", dst, err)
	}

	return nil
}

func inspect(src string) (TypeInfos, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, src, func(f os.FileInfo) bool {
		return strings.HasSuffix(f.Name(), ".go") && !strings.HasSuffix(f.Name(), "_test.go")
	}, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("Run: fail to parse from dir: src=%s, error=%w", src, err)
	}

	tinfos := TypeInfos{}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			for _, decl := range f.Decls {
				gd, ok := decl.(*ast.GenDecl)
				if !ok || gd.Tok != token.TYPE {
					continue
				}
				for _, spec := range gd.Specs {
					tspec := spec.(*ast.TypeSpec)
					tinfo := typ(tspec.Type, NewTypeInfo(pkg.Name, tspec.Name.Name))
					tinfos = append(tinfos, tinfo)
				}
			}
		}
	}

	tinfos = tinfos.Post()

	return tinfos, nil
}

type TypeInfos []*TypeInfo

func (ts TypeInfos) Interfaces() []*TypeInfo {
	ret := make([]*TypeInfo, 0, len(ts))
	for _, t := range ts {
		if t.IsInterface {
			ret = append(ret, t)
		}
	}
	return ret
}

func (ts TypeInfos) Post() TypeInfos {
	imap := make(map[string]struct{}, len(ts))
	for _, t := range ts.Interfaces() {
		imap[t.Name] = struct{}{}
	}

	p2cs := map[string][]string{}
	for _, t := range ts.Interfaces() {
		for _, p := range t.Parent {
			p2cs[p] = append(p2cs[p], t.Name)
		}
	}

	for _, iface := range ts.Interfaces() {
		// フィールドが interface を返すのか struct を返すのかを区別したい
		for _, finfo := range iface.FieldInfos {
			_, finfo.IsInterface = imap[finfo.TypeName]
			if finfo.IsInterface && 2 <= finfo.ArrayCount {
				panic(fmt.Errorf("Multi-dimensional arrays are not supported"))
			}
		}
		// Child埋める
		if cs, ok := p2cs[iface.Name]; ok {
			iface.Child = cs
		}
	}

	return ts
}

type TypeInfo struct {
	PkgName     string
	TypeName    string
	Name        string
	IsInterface bool
	IsArray     bool
	ArrayCount  int
	Parent      []string
	Child       []string
	FieldInfos  []*FieldInfo
}

func (t TypeInfo) ChildCount() int {
	return len(t.Child)
}

func NewTypeInfo(pkgName, name string) *TypeInfo {
	return &TypeInfo{
		PkgName:    pkgName,
		Name:       name,
		Parent:     make([]string, 0, 10),
		Child:      make([]string, 0, 10),
		FieldInfos: make([]*FieldInfo, 0, 10),
	}
}

func typ(expr ast.Expr, info *TypeInfo) *TypeInfo {
	switch t := expr.(type) {
	case *ast.Ident:
		info.TypeName = t.Name
	case *ast.ArrayType:
		info.IsArray = true
		info.ArrayCount++
		info = typ(t.Elt, info)
	case *ast.InterfaceType:
		info.IsInterface = true
		for _, method := range t.Methods.List {
			switch mt := method.Type.(type) {
			case *ast.Ident:
				// interface in interface
				tspec, ok := mt.Obj.Decl.(*ast.TypeSpec)
				if !ok {
					return info
				}
				info.Parent = append(info.Parent, mt.Name)
				info = typ(tspec.Type, info)
			case *ast.FuncType:
				// 引数取らず値を一つだけ返すやつに絞る
				if mt.Params.NumFields() != 0 {
					continue
				}
				if mt.Results.NumFields() != 1 {
					continue
				}
				mname := method.Names[0].Name
				finfo := field(mt.Results.List[0].Type, NewFieldInfo(mname))
				info.FieldInfos = append(info.FieldInfos, finfo)
			default:
				panic(fmt.Errorf("method.Type(%T) does not support", mt))
			}
		}
	}
	return info
}

type FieldInfo struct {
	Name        string
	PkgName     string
	TypeName    string
	IsArray     bool
	ArrayCount  int
	IsStar      bool
	IsObj       bool
	IsInterface bool
}

func NewFieldInfo(name string) *FieldInfo {
	return &FieldInfo{
		Name: name,
	}
}

func (f FieldInfo) FullTypeName() string {
	str := ""
	if f.IsArray {
		str += strings.Repeat("[]", f.ArrayCount)
	}
	if f.IsStar {
		str += "*"
	}
	if f.PkgName != "" {
		str += f.PkgName + "."
	}
	str += f.TypeName
	return str
}

func (f FieldInfo) String() string {
	return f.Name + "() " + f.FullTypeName()
}

func field(expr ast.Expr, info *FieldInfo) *FieldInfo {
	switch rt := expr.(type) {
	case *ast.Ident:
		info.TypeName = rt.Name
		info.IsObj = rt.Obj != nil
	case *ast.ArrayType:
		info.IsArray = true
		info.ArrayCount++
		info = field(rt.Elt, info)
	case *ast.StarExpr:
		info.IsStar = true
		info = field(rt.X, info)
	case *ast.SelectorExpr:
		x, ok := rt.X.(*ast.Ident)
		if !ok {
			break
		}
		info.PkgName = x.Name
		info = field(rt.Sel, info)
	}
	return info
}
